---------------------------------------------------------------------
-- 1. Уровни изоляции
-- Для всех заданий этого пункта в первой строке должно быть приведено
-- объявление начала транзакции. Предшествующие строки должны
-- содержать комментарии (--), обосновывающие выбор уровня изоляции
-- транзакции.
---------------------------------------------------------------------

---------------------------------------------------------------------
-- 1.1. FreeSeats
---------------------------------------------------------------------

-- Выполняется только чтение, поэтому не требуется уровень изоляции
-- serializable и snapshot: можно не переживать насчет про косой
-- записи, а появление фантомной записи, так как реализация построена
-- таким образом, что это не повлияет на результат, так как повторное
-- чтение происходит только после except, а значит, фантомная запись
-- не появится в ответе.
-- Даже если добавится бронь или будет куплено место, мы все читаем
-- по одному разу и можем считать, что FreeSeats выполняется раньше,
-- так что не трубуется повторяемость чтения - можем опустить уровень
-- до read committed.
-- Грязного чтения допускать не хочется, так как могут занять место,
-- а затем произойдет rollback, но это место уже не попадет в список
-- свободных - опустить уровень изоляции до read uncommitted нельзя.
start transaction read only isolation level read committed;

---------------------------------------------------------------------
-- 1.2. Reserve
---------------------------------------------------------------------

-- Насчет косой записи можно не переживать, так как нет никакого
-- правила, связывающего записи между собой, мы всегда проверяем
-- только одну сущность, поэтому serializable не требуется.
-- Фантомная запись тоже не станет проблемой, так как из таблицы с
-- пользователями мы чиатаем данные единожды, из таблицы рейсов и
-- мест более одного раза, но первый из них - это проверка, что место
-- существует, чтобы по-разному обрабатывать случаи бронирования
-- несуществующего места и бронирование занятого места, так что в
-- дальнейшем мы прицельно проверяем именно то место, про которое
-- мы точно знаем, что оно существовало во время начала выполнения
-- функции. Таким образом, можем отказаться от snapshot.
-- Неповторяемое чтение не является проблемой, так как если
-- параллельно с нами кто-то забронировал место, мы можем считать,
-- что сделали это раньше.
-- Опустить до read uncommitted не можем как минимум потому что
-- транзакция не read only.
start transaction read write isolation level read committed;

---------------------------------------------------------------------
-- 1.3. ExtendReservation
---------------------------------------------------------------------

-- Насчет косой записи можно не переживать, так как нет никакого
-- правила, связывающего записи между собой, мы всегда проверяем
-- только одну сущность, поэтому serializable не требуется.
-- Атомарно читаем из трех разных таблиц по одному разу, поэтому не
-- требуется уровень изоляции snapshot.
-- От repeatable read отказаться не можем, так как возможна ситуация,
-- когда мы проверили, что бронирование оформлено на соответствующего
-- пользователя, однако между проверкой и обновлением бронь истекла и
-- сменился владелец брони. Во избежание продления чужого
-- бронирования требуются гарантии, что раз бронь существовала во
-- время первой проверки, то она существует и во время обновления.
start transaction read write isolation level repeatable read;

---------------------------------------------------------------------
-- 1.4. BuyFree
---------------------------------------------------------------------

-- Насчет косой записи можно не переживать, так как нет никакого
-- правила, связывающего записи между собой, мы всегда проверяем
-- только одну сущность, поэтому serializable не требуется.
-- Проверка учетных данных происходит атомарно, проверка того, что
-- место свободно - тоже. Это все требует однократных чтений таблиц
-- с данными пользователей, рейсов, мест, бронирований и покупок, так
-- что нам до этого момента не страшны фантомные записи и
-- неповторяемое чтение.
-- Фантомная запись может возникнуть, когда параллельно происходит
-- покупка одного и того же места и в обоих случаях дошло до вставки,
-- однако она не является проблемой - запись вставится всего одна,
-- а другие записи закончатся исключениями из-за повторений ключа.
-- Таким образом, от snapshot можно избавиться.
-- Отказаться от repeatable read мы не можем, так как если сначала
-- посчитаем место свободным, а потом его забронирует кто-то другой,
-- то начнутся проблемы как минимум с тем, что будет активная бронь
-- на купленное место, так что нам требуются гарантии, что раз мы уже
-- убедились, что место свободно - оно будет свободно пока мы не
-- закончим покупку.
start transaction read write isolation level repeatable read;

---------------------------------------------------------------------
-- 1.5. BuyReserved
---------------------------------------------------------------------

-- Насчет косой записи можно не переживать, так как нет никакого
-- правила, связывающего записи между собой, мы всегда проверяем
-- только одну сущность, поэтому serializable не требуется.
-- Проверка учетных данных происходит атомарно, как и проверка того,
-- что место забронировано. На протяжении всей транзакции место
-- считается забронированным за пользователем, если так было на
-- момент проверки, а значит, бронь можно либо продлить, либо
-- выкупить. Если параллельно выполняется ExtendReservation, то
-- либо он увеличит значение timestamp, что никак не повлияет на
-- возможность выкупа места, либо не успеет и произойдет удаление
-- брони, тогда его транзакция откатится и это также выглядит
-- валидно. Если же параллельно выполняется второй BuyReserved
-- (BuyFree закончится на проверке того, что место свободно), то
-- кто-то первым создаст запись в таблице покупок, а остальные
-- откатятся из-за дублирования ключа. Таким образом, можно
-- отказаться от snapshot.
-- От repeatable read отказаться не можем по похожим причинам, что и
-- в BuyFree: если мы проверили, что место забронировано именно нами,
-- то мы хотим быть уверены, что до окончания покупки не закончится
-- наша бронь и место не забронирует кто-то другой.
start transaction read write isolation level repeatable read;

---------------------------------------------------------------------
-- 1.6. FlightsStatistics
---------------------------------------------------------------------

-- Косой записи произойти не может, потому что транзакция read only,
-- так что может отказаться от serializable, но требуется уровень
-- изоляции snapshot, так как нас не устраивают фантомные записи:
-- В некоторой очередноси происходят чтения - всех мест, всех
-- забронированных, всех купленных, забронированных конкретным
-- пользователем, купленных конкретным пользователем.
-- Если при повторном чтении забронированных или купленных мест
-- появится фантомная запись, то данные в ответе будут несогласованы
-- между собой, например, мы покажем, что все места свободны, но
-- у пользователя есть бронь. Недопустимость возникновения фантомных
-- записей достаточный аргумент для выбора уровня изоляции snapshot,
-- так как все более низкие уровни изоляции допускают возникновение
-- фантомных записей.
start transaction read only isolation level snapshot;

---------------------------------------------------------------------
-- 1.7. FlightStat
---------------------------------------------------------------------

-- В данном случае актуальны все те же самые рассуждения, что и для
-- функции FlightsStatistics. На всякий случай продублирую их:
-- Косой записи произойти не может, потому что транзакция read only,
-- так что может отказаться от serializable, но требуется уровень
-- изоляции snapshot, так как нас не устраивают фантомные записи:
-- В некоторой очередноси происходят чтения - всех мест, всех
-- забронированных, всех купленных, забронированных конкретным
-- пользователем, купленных конкретным пользователем.
-- Если при повторном чтении забронированных или купленных мест
-- появится фантомная запись, то данные в ответе будут несогласованы
-- между собой, например, мы покажем, что все места свободны, но
-- у пользователя есть бронь. Недопустимость возникновения фантомных
-- записей достаточный аргумент для выбора уровня изоляции snapshot,
-- так как все более низкие уровни изоляции допускают возникновение
-- фантомных записей.
start transaction read only isolation level snapshot;

---------------------------------------------------------------------
-- 1.8. CompressSeats
---------------------------------------------------------------------

-- Фантомные записи могут возникнуть при параллельной покупке и
-- бронировании мест и в процессе обновления мы получим ситуацию
-- при которой какие-то места сожмутся, а какие-то нет. Или если
-- место перейдет из забронированных в купленные, то оно должно будет
-- оказаться в другом месте в сортировке.
-- Косая запись не является проблемой, так как нет каких-то условий
-- на соотношение полей нескольких записей в таблице (инварианта).
start transaction read write isolation level snapshot;

---------------------------------------------------------------------
-- 2. Сценарий
---------------------------------------------------------------------

---------------------------------------------------------------------
-- 2.0. Общий план
-- Изложите общий план реализации, в том числе на каком этапе какие
-- данные будут получены и как использованы
---------------------------------------------------------------------

Приложение будет обращаться к базе данных, запросит у нее список
свободных мест. Перед пользователем откроется интерфейс выбора места,
который отобразит полученные от базы данных места. Пользователь
выберет место и сможет его забронировать или купить. Для обоих
случаев в базе данных имеются функции и процедуры, так что приложение
снова обратиться к базе данных с требуемым уровнем изоляции
транзакции, вызовет требуемую функцию, передаст данные пользователя,
если они имеются, а также информацию о месте, получит результат и
сообщит пользователю, удалось ли совершить бронирование или покупку.

---------------------------------------------------------------------
-- 2.1. Запрос списка свободных мест
-- Приведите соответствующие SQL-запросы
---------------------------------------------------------------------

start transaction read only isolation level read committed;

select
    *
from
    FreeSeats(:FlightId);

commit;

---------------------------------------------------------------------
-- 2.2. Взаимодействие с пользователем
-- Укажите как будет релизовано взаимодействие с пользователем
---------------------------------------------------------------------

Пользователь выберет рейс и откроет список свободных мест на данном
рейсе. В это время приложение сделает запрос в базу данных и
отобразит результат пользователю.
Если пользователь не авторизован, то он не может забронировать или
купить забронированное место, так что единственная доступная ему
опция - купить свободное место, он может выбрать его из списка и
тогда приложение снова сможет обратиться к базе данных для выполнения
функции BuyFree, а по получении результата, показать сообщение о
том, что покупка завершена успешна или о том, что место оказалось
занятым. Во втором случае можно перезапросить список свободных мест
и предложить пользователю попробовать снова совершить покупку.
Если пользователь авторизован, то все аналогично, но для него
доступно три опции - анонимная покупка билета (все аналогично
предыдущему пункту), либо бронирование, либо покупка. Во втором и
третьем случае принципиальная разница состоит только в том, какая
функция базы данных будет вызвана, в остальном все также - если
база данных сообщает, что бронирование/покупка прошло успешно, то
можем порадовать пользователя, иначе - показать понятное сообщение
об ошибке и предоложить выбрать место заново.

---------------------------------------------------------------------
-- 2.3. Действия с местом
-- Приведите соответствующие SQL-запросы
---------------------------------------------------------------------

-- Анонимная покупка или покупка без авторизации.
start transaction read write isolation level repeatable read;

select BuyFree(
    :FlightId,
    :SeatNo
);

commit;

-- Бронирование места авторизованным пользователем.
start transaction read write isolation level read committed;

select Reserve(
    :UserId,
    :Pass,
    :FlightId,
    :SeatNo
);

commit;

-- Покупка забронированного места авторизованным пользователем.
start transaction read write isolation level repeatable read;

select BuyReserved(
    :UserId,
    :Pass,
    :FlightId,
    :SeatNo
);

commit;
