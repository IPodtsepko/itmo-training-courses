# Вариант 10. Заголовок функции в Си

Заголовок функции в Си. Заголовок начинается именем возвращаемого типа
или словом `"void"`, далее следует имя функции, скобка, затем разделеные
запятой описания аргументов. Переменная может быть указателем, в этом случае
перед ней идет звёздочка (возможны и указатели на указатели и т.д.).
Аргументов может быть несколько.

Используйте один терминал для всех переменных и имен типов.

Пример: `int fib(int n);`

## Разработка грамматики

Для понимания можно сформулировать грамматику следующим образом:
    
```
Function -> Type Name(Args);
Type -> Type* // Тип может быть указателем
Type -> Name
Args -> Type NameTail
Args-> ε
Tail -> , Type NameTail
Tail -> ε
Name -> word
```

Удалим избыточный смысл:

```
F -> T N(A);
T -> T*
T -> N
A -> T NB
A -> ε
B -> , T NB
B -> ε
N -> w
```

Избавимся от левой рекурсии, которая видна в правиле `T -> T*`:
```
F -> T N(A);
T -> NP
P -> *P
P -> ε
A -> T NB
A -> ε
B -> , T NB
B -> ε
N -> w
```
## Построение множеств `FIRST` и `FOLLOW`:

| Нетерминал | `FIRST`  | `FOLLOW`           |
|------------|----------|--------------------|
| `F`        | `w`      | `$`                |
| `N`        | `w`      | `(`, `*`, `,`, `)` |
| `T`        | `w`      | `w`                |
| `P`        | `*`, `ε` | `w`, `*`           |
| `A`        | `w`, `ε` | `)`                |
| `B`        | `w`, `,` | `)`                |

## Использование парсера

Entry point программы - `src/Main.java`. После запуска программа считывает ввод из `System.in` и завершения ввода
печатает описание графа в `./outfile.dot`. Затем она автоматически генерирует картинку в формате "svg" командой
`dot -Tsvg outfile.dot -o outfile.svg`. Убедитесь, что `dot` установлен.

В каталоге `test` представленны тесты лексера - `LexicalAnalizerTest.java`, и тесты парсера - `ParserTest.java`,
написанные на основании грамматики, описанной выше.

## Модификация

Добавить поддержку ссылок (&). Удобно, что

1. Не бывает указателей на ссылки;
2. Не бывает ссылок на ссылки (в явном виде точно):
```cpp
using Reference = int &;
using DoubleReference = Reference &;
DoubleReference & f();
int & & g(); // ???
```

Таким образом, добавим в грамматику новое правило:
```
P -> *P
P -> ε
P -> & // Новое правило
```