# Операционные системы (3 семестр, Маятин)

## Лекция 1

**Операционная система** - базовое системное программное обеспечение, управляюще работой вычислительного узла и реализующее универсальный интерфейс между аппаратным обеспечением, программным обеспечением и пользователем.

### Первый этап эволюции ОС: программы-диспетчеры

**Принципы архитектуры Фон Неймана**
1. Однородность памяти (код и данные в единой памяти)
2. Принцип адресности (оперативная память представляет собой линейно адресуемое пространство и процессор может обратиться к произвольной ячейке памяти в любой момент)
3. Программное управление
4. Всё кодируется с помощью двоичного кода

*Архитектуру Фон Неймана реализуют начиная с 40-х годов XX в.*

Процессор выполнял программы последовательно, инкрементируя адрес инструкции. Некоторые функции было необходимо использовать многократно. Чтобы не повторять один и тот же участок кода появилась идея использовать часть памяти для хранения часто повторяющихся инструкций (подпрограмм). Чтобы знать куда вернуться после выполнения подпрограммы создали **программы-диспетчеры**.

Процессор выполнял и работу с памятью, и вычисления. Очевидно, что для работы с памятью не требуется вся мощность процессора, поэтому создали **контроллеры**, которые умели только вычислять адреса и подгружать/выгружать данные.

**Прерывание** - сигнал, поступающий от внешнего устройства к ЦП, приостанавливающий выполнение текущего набора команд и передающий управление подпрограмме - обработчику прерываний. Работа с помощью контроллера - SPOOLing.

**Пакет** - совокупность программных модулей и данных (например, констант).

**Пакетная обработка (batch processing)** - выполнение "заданий, которые могут выполняться без взаимодействия с конечным пользователем или могут быть запланированы для выполнения, если позволяют ресурсы" (определение из интернета).

*Реализация пакетной обработки требует создания алгоритмов планирования, о которых будет вестись речь в дальнейшем.*

### Второй этап эволюции ОС: мультипрограммные ОС

*Идея*: несколько программ можно параллельно (фактически стали выполнять *псевдопараллельно*, так как количество потоков существенно превышало количество ядер, каждому процессу выделяется некоторое время для работы - кванты непрерывного выполнения, их длительность не превышает 1 мс).

**Варианты реализации псевдопараллельного выполнения:**
1. Использовать в коде специальные метки для переключения между потоками (раньше отказались, сейчас реализовано, например, в коорутинах Kotlin).
2. Таймер генерирует прерывания (уже были кварцевые часы), а обработчик прерываний решает, какой процесс дальше должен выполняться. Данный метод требует решения следующих задач:
   1. *Работа с регистрами*. Если программа загрузила данные в регистры, было сгенерированно прерывание, другой процесс испортил данные в регистрах, то после этого программа не сможет работать корректно. Решение - сохранение регистровых контекстов.
   2. *Работа с памятью*. Код нового процесса может быть где угодно, поэтому непонятно, как выполнять адресацию. Решение - концепция виртуальной памяти, использовать виртуальные адреса и подменять их физическими (*когда пересчитывать адреса?*).
   3. *Обеспечение защиты программных данных от других программ*. Программа может ошибиться с адрессаций и испортить данные "коллеги". Введена концепция защиты памяти, реализованная аппаратно, а также привелегированный режим - режим процессора, при котором отключается защита памяти.
        * **System call** - абстракция аналогичная механизму прерываний между ОС и ПО, обращение пользовательской программы к ядру ОС с требованием предоставить ресурсы и выполнить привелегированную операцию.
   4. *Планирование выполнения программы и использования ресурсов*. Теперь очередей много и они могут быть связаны между собой, а алгоритмы планирования должны быть высокопроизводительными. Представим, что есть два неразделяемых ресурса (r<sub>1</sub> и r<sub>2</sub>) и две программы (p<sub>1</sub> и p<sub>2</sub>). p<sub>1</sub> захватилa ресурс r<sub>1</sub>, p<sub>2</sub> захватила ресурс r<sub>2</sub>, в процессе выполнения программе p<sub>1</sub> потребовался ресурс r<sub>2</sub>, p<sub>2</sub> - r<sub>1</sub>. Такая ситуацию назвали **тупиком**. Данную проблему решал Дейкстра на протяжении 15-ти лет и в дальнейшем ей занимались его ученики. 
   5. *Универсальный доступ к информации на внешних устройствах*. Раннее внешнаяя память была устроена линейно, как RAM. Однако такой подход неэффективен, так как не понятно, какие разделы (конечного размера) выделять программам, что делать, если несколько программ хотят работать с одной областью памяти. Введено понятие *файла*.
        * **Файл** - именованная совокупность данных. Для удобства введена **файлово-каталожная модель доступа к файлам**, которая сейчас реализована разными способами (например, Windows использует древовидную модель, в Linux реализуют виртуальную структуру).
   6. *Обеспечение комуникации между программами*. Механизмы:
        * **Буфер** - область памяти, в которую можно класть информацию, которую необходимо передать в другой процесс.
        * **Конвееры** (1 лабораторная) - перенаправление потоков ввода и выводы в другие процессы.
        * **Именованные каналы** (3 лабораторная) - обмен сигналов между программами.
        * **Виртуальная машина** - механизм, который реализует изоляцию процессов и завершает концепцию операционной системы (50 - 60-е годы).

**Первая операционная система** (*1963 г, суперкомпьютер B5000 компании burroughs*) - MCP (main control program).

*На данном этапе развития были специальные заведения, в которых можно было ареновать машинное время, передать оператору перфокарту и выполнить программу (узнать, что ошибся в одном байте -_-).*


### Третий этап эволюции ОС: сетевые операционные системы.
*Теперь компьютеры стали более популярны, поэтому затраты на гостиницы и доставку перфокарт до ближайшего города с компьютером стали слишком не выгодны. Хочется многотерминальности. Идея - передавать сигнал удаленно (если что, по телефону диктовать код программы неудобно).*

**Модем** - модулятор/демодулятор. Передаёт аналоговый сигнал (например синусоиду), по которому можно определить 0 и 1.

**AT&T** - одна из первых компаний, которая стала заниматься реализацией многотерминальности, выкупала компьютеры и предоставляла вычислительные мощности ползователям.

**Проблемы**:
1. Поскольку теперь много терминалов, необходимо решать вопросы безопасности в условиях многопользовательского режима, пользователи могут иметь разные намерения. Появляются понятия *учетной записи*, *авторизации*, *аутентификации* и т. д.
2. Чем дальше компьютер - тем хуже сигнал, поэтому пользователи выбирают ближайшие компьютеры, однако нагрузка может разделяться неравномерно. Решение: некоторые компании выкупали замкнутые связи и перенаправляли пакеты на свободные вычислительные мощности - реализовывали **механизм сетевого обмена заданиями**, то, что мы сейчас воспринимаем как облака.

*- Кстати, очень советую, у нас есть музей связи. Может быть, кто-то был, он недалеко от Исакиевского Собора. Всем, кто занимается IT, я вообще просто советую туда сходить.*
